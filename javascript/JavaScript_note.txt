JavaScript手记

JS的发展史
    1、1992年时，开发了一款脚本语言 - ScriptEase,可以嵌入在网页中的脚本语言
    2、1995年，Netscape(网景)为Navigator2.0 浏览器设计了一款脚本语言LiveScript,更名为 JavaScript
    3、1996年，Microsoft在IE3.0中发布了一款JavaScript的克隆版本，称为 JScript
    4、1997年，JavaScript1.1 提交给了 ECMA(欧洲计算机制造商协会)，各个厂家合力推出 ECMA-262的标准,并且将核心定义为ECMAScript

JS的组成
    完整的JS是由三部分组成：
    1、JS核心(ECMAScript)
    2、文档对象模型(DOM,Document Object Model)
        W3C定义的规范,允许Javascript能够与网页进行交互
    3、浏览器对象模型(Browser Object Model)
        允许JavaScript能够与浏览器进行交互

浏览器内核
    浏览器    内核     排版引擎      解释引擎
    IE        Trident     -          Chakra
    Firefox   Gecko       -          Monkey系列
    Safari    Webkit    Webcore      Nitro
    Chrome    Webkit    Webcore      V8
    Opera     Presto      -          Carakan
    Opera     Webkit    Webcore      V8


变量
    什么是变量
    内存：保存程序运行过程中所需要用到的"数据"
    空间：
        位 ：bit     8bit = 1byte
        字节：byte   1024byte = 1kb
        千字节：kb   1024kb = 1mb
        兆字节：mb   1024mb = 1gb
        G : gb       1024gb = 1tb
        T : tb
常量
    1、变量与常量
        变量：是一个可以变化的数据
        常量：是一个不能变化的数据
        常量的特点：
            在程序中，一旦被声明好，在程序运行过程中就不允许被修改
    2、语法
        const 常量名=值;
        注意：
            1、声明常量时必须赋值
            2、通常，常量名称采用全大写形式(规范)


数据类型
    1、作用
        决定了数据在内存中所占的空间大小
    2、数据类型分类
        原始类型(基本类型)
            1.number类型
                可以表示32位的整数，也可以表示64位的浮点数
                整数：32位空间(4字节)
                浮点数：小数，64位空间(8字节)
                整数：
                    1、保存十进制数字
                        由0-9共10个数字组成，逢10进1
                        var age = 35;
                    2、保存八进制数字
                        由0-7共8个数字组成，逢8进1
                        JS中，八进制数字值，由0开始
                        var num=010;
                    3、保存十六进制数字
                        由0-9，A-F 共 16个数字组成，逢16进1
                        JS中，十六进制数字，由0x开始
                        var num=0x10;
            2.string类型
                由Unicode字符，数字，标点符号组成的序列
                Unicode : 编码方式之一，可以由一组十六进制的数字(Unicode码)来表示一个字符。
                每个字符在计算机内存中，占2个字节
                如何查看字符的Unicode码？？？
                字符.charCodeAt(); 十进制表示方式
                字符.charCodeAt().toString(2); 二进制
                字符.charCodeAt().toString(16);十六进制
                张：24352(十进制)
                张：0101111100100000(二进制)
                张：5f20(十六进制)
                中文汉字的范围：
                从 \u4e00 开始  到  \u9fa5 结束
                注意：在EAMAScript中，定义字符串时双引号与单引号表示完全相同
                    null值 转换返回"null"
                    undefined 装换返回"undefined"
            3.boolean类型
                true ：真
                false ：假
                在实际运算中true当做1运算，false当做0运算
            4.undefined
            5.null
                这个特殊的值是null，从逻辑的角度看，null值表示一个空对象指针
        引用类型
            Object类型
            注意：
                Object的每个实例都具有下列属性和方法
                1.constrector:保存着用于创建当前对象的函数。构造函数
                2.hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。
                  其中，作为参数的属性名(propertyName)必须以字符串形式指定
                  例如:o.hasOwnPerperty('name');
                3.isPrototypeOf(Object):用于检查传入的对象是否是传入对象的原型
                4.propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。
                  与hsaOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定
                5.toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应
                6.toString():返回对象的字符串表示
                7.valueOf():返回对象的字符串、数值或布尔值表示，通常与toString()方法的返回值相同




数据类型转换
    弱类型语言：由数据决定数据类型
    函数：var 变量=typeof(变量);

    1、隐式转换
    不同数据类型之间的数据在计算过程中会自动进行转换
        (1)数字 + 字符串 ：将数字转换为字符串，整体结果为字符串
        (2)数字 + 布尔类型：将布尔类型转换为数字，整体结果为 数字
        (3)字符串 + 布尔类型：将 布尔类型转换为 字符串，整体结果为 字符串
        (4)布尔类型+布尔类型：将 布尔类型转换为 数字，整体结果为 数字
        注意：字符串和任意数据类型的数据相加运算时，结果都为字符串
    2.转换函数
        (1)toString()
            作用：将任意类型的数据转换为字符串类型
            返回值：转换后的结果
            语法：var 变量=变量.toString();
        (2)parseInt(参数)
            作用：将任意类型的数据转换为 "整数"
            参数：待转换的数据
            返回值：转换后的结果(number类型)
            特点：
                1、碰到第一个非数字字符就停止转换
                2、如果第一个字符就是非数字字符，转换结果为NaN(Not a Number)
                    isNaN(参数) : 判断 参数 是否为 非数字
                        返回值为 false，则为 数字
                        返回值为 true ，则为 非数字
        (3)parseFloat(参数)
            作用：将 参数 转换为 小数(浮点数)
            参数：待转换的数据
            返回值：转换后的结果(number类型)
        (4)Number(参数)
            作用：将一个 string 类型的参数 转换为 number
            参数：待转换的数据
            返回值：转换后的结果(number)
            注意：如果包含非法字符，则返回 NaN
                boolean值 true和false 转换为1和0
                null值 返回0
                undefined 返回NaN
                空字符串 返回0




运算符 和 表达式
	运算符：实现数据运算的一组符号
	操作数：辅助运算符进行运算的数据
		15 + 10
	表达式：由运算符 和 操作数 组成的式子
		var num = 15;
		注意：每一个表达式都会有运算结果
    1、算术运算符
        +,-,*,/,%,++,--
        注意：
            除 + 外，其他的运算符如果两边的操作数不是number类型的话，会自动使用Number()进行转换然后再做运算

            任何数据在与NaN做运算时，结果一定是NaN
        优先级
            除 ++，--外
            运算顺序：从左向右，先 */%，后+-
        ++，--
            ++ ：自增运算符,在自身的数值基础上做+1操作
            -- ：自减运算符,在自身的数值基础上做-1操作
            注意:boolean值 不支持自增自减
                string值 不支持自增自减
    2.关系运算符
        (1)作用
            比较数据之间的大小，相等关系的
            由关系运算符所组成的表达式称之为"关系表达式"
            关系表达式的结果都是 boolean 类型
        (2)关系运算符
            >,<,>=,<=,==(判断等于),!=(不等于),===(全等)，!==(不全等)
            注意：
            1、运算符两边如果有一个是number类型的话，另一个非number类型的数字会通过Number()隐式转换为 number 在进行比较
            2、如果运算符两边都是 string 类型的话，那么比较的就是每位字符的Unicode码，不相同的字符比较出大小，Unicode码的胜出
            === : 全等，既要判断数值，还要判断数据类型，数值和类型都相等的情况下，才为真，否则就为假
    3.逻辑运算符
        !:非(取反)
            对现有条件的结果进行取反操作
            非真即假
            非假即真
        &&:逻辑与
            作用：关联两个条件
                如果两个条件的值都为真的话，则整个逻辑结果就为真
                如果两个条件中，有一个条件值为假，则整个逻辑结果就为假
        || : 逻辑或
            关联的两个条件中，只要有一个结果为真，那么整个的结果就为真
        优先级：
            !>&&>||
            比较运算符 > 逻辑运算符
    4.短路逻辑
        (1)短路 与
            条件1 && 条件2

            如果条件1的结果为假的话，那么就"不会判断执行条件2"，整个表达式的值，就为假
            如果条件1的结果为真的话，那么则"继续判断执行条件2"，并且以条件2的结果作为整个逻辑表达式的结果
        (2)短路 或
            条件1 || 条件2

            如果条件1的结果为真的话，那么久"不会判断执行条件2"，整个表达式的值，就为真
            如果条件1的结果为假的话，那么则"继续判断执行条件2"，并且以条件2的结果作为整个逻辑表达式的结果
    5.运算符
        (1)位运算符
            作用：
                针对数字操作
                将数字先转换为二进制再进行运算操作
            二进制：
                由0,1组成,逢二进一
                十进制        二进制
                0             0
                1             1
                2             10
                3             11
                4             100
                5             101
                6             110
                ... ...

            运算符：
                1、&(按位与)
                    语法：num1 & num2
                    作用：将两边的操作数转换为二进制，每位数字进行按位比较,对应位置的数字都为1的时候，该位结果才为1，否则为0
                    ex:
                        3 & 5 : 1

                        3:011
                        5:101
                        =========
                          001

                        12 & 7 : 4
                        12:1100
                         7:0111
                         ==========
                           0100
                        1、15 & 1 : 1
                            15:1111
                             1:0001
                             ======
                               0001
                        2、18 & 1 : 0
                        3、37 & 1 : 1
                        4、26 & 1 : 0
                        5、12345 & 1 : 1
                        6、78966 & 1 : 0

                    场合：判断一个数字的奇偶性，num & 1,如果结果为1，num则为奇数，否则为 偶数
                2、|(按位或)
                    语法：num1 | num2
                    作用：将两边的操作数转换为二进制，每位数字进行按位比较,对应位置的数字只要有一个为1的时候，该位的结果就是1
                        ex:
                            1 | 3
                            1:01
                            3:11
                            =====
                              11  = 3

                            5 | 7
                            5:101
                            7:111
                            =====
                              111 = 7

                            5:101
                            3:011
                            =====
                              111 = 7
                    场合：将小数做向下取整操作
                3、^(按位异或)
                    语法：num1 ^ num2
                    作用：将两边的操作数转换为二进制，按位比较，对应位置只有一个1的时候才返回1，否则返回0
                    ex :
                        5 ^ 3 = 6
                        5 : 101
                        3 : 011
                        =============
                              110
                    场合：在不借助第三方变量时交换两个数字的位置
                        ex:
                            var num1 = 5;
                            var num2 = 3;

                            num1 = num1 ^ num2; //num1 = 6
                                5 : 101
                                3 : 011
                                =======
                                    110  = 6
                            num2 = num2 ^ num1;//num2 = 5
                                3 : 011
                                6 : 110
                                ========
                                    101 = 5
                            num1 = num1 ^ num2;//num1 = 3
                                6 : 110
                                5 : 101
                                =======
                                      011 = 3
                4、<<(按位左移)
                    语法：num<<n
                    作用：将num转换成二进制，并且向左移动n位，右侧以0补齐
                    ex: 2<<1 = 4
                        2
                        0000 0000 0000 0000 0000 0000 0000 0010
                        2<<1 = 4
                        0000 0000 0000 0000 0000 0000 0000 0100
                        2<<2 = 8
                        0000 0000 0000 0000 0000 0000 0000 1000
                5、>>(按位右移)
                    语法：num>>n
                    作用：将num转换成二进制，并且向右移动n位，左侧以0补齐
                    ex:8>>2
                    8
                    0000 0000 0000 0000 0000 0000 0000 1000
                    8>>2 = 2
                    000000 0000 0000 0000 0000 0000 0000 10

                    7>>1
                    7
                    0000 0000 0000 0000 0000 0000 0000 0111
                    7>>1 = 3
                    00000 0000 0000 0000 0000 0000 0000 011
        (2)赋值运算
            赋值运算符：=
                变量 = 值;
                注意：=的左侧必须是变量
            扩展的赋值表达式：
            +=,-=,*=,%=,/=,^=,... ...
            a+=b; 等价于 a=a+b;
            ex:
                var num = 10;
                num += 5;//num=num+5;
                console.log(num);

                num = 10;
                num *= 3;//num = num * 3
                console.log(num); // 30

                var a = 5;
                var b = 3;

                a = a ^ b; // a^=b;
                b = b ^ a; // b^=a;
                a = a ^ b; // a^=b;
        (3)条件运算符(三目运算符)
            目：操作数
                单目运算符：只有一个操作数，++,--,!
                双目运算符：有两个操作数,+,-,*,...
                三目运算符：要求有三个操作数

            条件运算符：
                ? :
                表达式1 ? 表达式2 : 表达式3;
                表达式1 ：是一个条件，结果为boolean类型
                如果表达式1的值为true，则执行表达式2
                如果表达式1的值为false，则执行表达式3




函数
    1.什么是函数
		函数(function),也被称为方法(method)或者过程(procedure)
		函数是一段预定义好，并可以被反复执行的代码块
			预定义好：
				事先被定义，但不会马上被执行。可以由任意元素的事件来调用(调用时被执行)
			反复执行：
				同一个函数，可以被多次调用
				提升了代码的可重用性
			代码块：
				允许包含多条可执行的语句

		函数的本质也是功能完整的对象
    2.作用域
        (1)什么是作用域
            作用域指的是变量或函数的可访问范围
            在JS中，变量和函数的作用域分为：
            函数作用域，只能在定义的函数内访问
            全局作用域，一经定义，任何位置都能用
        (2)声明提前
            JS在正式运行前，会将var声明的变量以及function声明的函数，预读到所在作用域的顶部。但是对变量的赋值仍然保留在原位置处
        (3)按值传递
            基本数据类型作为参数时，传参时，实际是将实参的值复制一个副本传递给函数
    3.ECMASript函数不能重载



分支结构
    1.if结构
        (1)语法
            if(条件){
                //语句块(满足条件时要做的操作)
            }

            条件：尽量放 boolean 的变量 或 表达式

            判断条件
                如果条件 为真的话，则执行语句块中的代码
                如果条件 为假，则跳过语句块，执行其他语句
        (2)注意
            1、条件如果不是boolean的话，则会自动转换，以下操作会自动将条件转换为 false，其他都是true
                if(0){}
                if(0.0){}
                if(undefined){}
                if(NaN){}
                if(""){}
                if(null){}

                ex:
                    if(35.0){} //true
                    if("Hello World"){}//true
                    if(0){} //false
         (3)if 后的 {} 可以省略不写，如果省略不写的话，那么if只控制它下面的第一条语句
    2.if ... else 结构
    3.else ... if 结构
    4."等值" 判断的分支结构 - switch
        (1)语法
            switch(变量/表达式){
                case 值1:
                    语句块1;
                    break; -- 结束switch的运行,可选的
                case 值2:
                    语句块2;
                    break; -- 结束switch的运行，可选的
                case ...:
                    语句块....;
                    break;
                default:
                    语句块n;
                    break;
            }
            流程：
                1、计算 switch后的 变量 或 表达式的值
                2、判断值与哪个case块后面的值能匹配上，匹配上哪个case块则执行哪个语句块
                3、碰到 break ， 则结束switch结构的运行，如果没有break，则继续执行后续的case块，直到碰到break，或执行结束为止
                4、如果任何case都没有匹配上的话，并且具备default模块的话，则执行default里面的内容。否则什么都不执行
            注意：
                1、各个case块与default之间的位置可以随便放
                2、JS 默认是采用 === 的方式做等值判断的
                    1 和 "1" 是不相等的



循环结构
    1.while 循环
        (1)语法
            while(条件){
                循环体(循环操作)
            }

            执行流程：
                1、判断条件,如果条件为真，则执行循环体中的内容，如果条件为假，则跳出循环结构
                2、执行完循环体，再一次判断条件，
            循环中的流程控制
			continue
				终止本次循环的执行，继续开始下次循环
				ex:
					打印 1 - 100之间所有非3的倍数的数字
			break
				结束整个循环的运行
				可以用在：不确定循环次数的时候去结束循环
				ex:
					要求用户 从弹框中 录入数据，录入完直接打印在控制台上，直到输入 exit 位置
    2.do...while 循环
        (1)特点
            先执行循环操作，再判断循环条件
        (2)语法
            do{
                循环操作
            }while(条件);
    3.for 循环
        (1)目的：为了简化 while 循环的开发
        for(表达式1;表达式2;表达式3){
            循环操作
        }
        表达式1：声明循环条件变量
        表达式2：循环条件判断
        表达式3：更新循环变量
        流程：
            1、计算表达式1的值 即声明循环条件(只执行1次)
            2、计算表达式2的值 即计算循环条件时否满足，如果条件为真，则继续向下执行，否则退出循环
            3、条件为真时，执行循环体
            4、计算表达式3的值 即更新循环变量
            5、计算表达式2的值 即继续判断循环条件，回到第2步
        (2)for 循环表达式的特殊用法
			1、表达式1 允许为空
				可以省略表达式1，但;不能省
				for(;条件;自增){

				}
				ex:
				var i=1;
				for(;i<=10;i++){
					console.log(i);
				}
			2、表达式2 允许为空
				可以省略表达式2，但;不能省
				如果省略表达式2，那么就是 "死循环"
			3、表达式3 允许为空
				死循环
			4、三个表达式都可以省略，但;不能省
				for(;;){
					if(条件)
						break;
					i++;
				}
			5、表达式1 和 表达式3 的多样化
				表达式1：允许声明多个变量，用,隔开
				表达式3：允许更新多个变量，用,隔开
    4.for-in语句
        for-in语句是一种精准的迭代语句，可以用来枚举对象的属性
        语法
        for(var propName in window){
            document.write(propName);
        }




数组
    什么是: 内存中连续存储多个数据的存储空间，再起一个名字
    vs
    变量: 只能存一个数据，数组可以存多个数据
    创建: 3种情况:
    1. 创建空数组:
     var arr=[];
     var arr=new Array();
     何时: 只要创建数组时，暂时不知道数组内容
    2. 创建数组同时，初始化数组内容:
     var arr=[值1, 值2, ...];
     var arr=new Array(值1, 值2, ...)
     何时: 只要创建数组时，已经知道数组内容
    3. 创建n个空元素的数组:
     var arr=new Array(n);
     何时: 只要创建数组时，只知道元素个数，不知道内容

    访问数组元素:
       元素: 数组中每个数据就是一个元素
       下标:  index 数组中唯一标识一个元素的序号
         默认从0开始，依次递增1
       获取:  arr[i]
       设置:  arr[i]=值
      总结: 数组中每个元素得用法和普通变量完全一样
        数组: 一组变量的集合，再起一个统一的变量名

    3个不限制:
      (1)不限制元素的数据类型:
      (2)不限制元素个数: 可随时向数组中添加新元素
      (2)不限制下标越界: 无论取值还是赋值时，下标越界都不报错！
         赋值: 自动添加一个新元素保存新数据
         取值: 不报错，仅返回undefined

    固定套路
        (1)获取数组最后一个元素: arr[arr.length-1]
           获取数组倒数第n个元素:arr[arr.length-n]
        (2)向数组末尾追加一个新元素:
          arr[arr.length]=值;
        (3)删除数组末尾一个元素: arr.length-=1;
           删除数组末尾n个元素:arr.length-=n;

    存储: 数组是引用类型的对象
    按值传递: 两变量间赋值或将变量作为参数传入函数时，都是将原变量中的值复制一个副本给对方
    原始类型的值: 修改新变量，不影响原变量！
    引用类型: 通过新变量修改原数组，原变量同样受影响。

    问题:
    console.dir(arr), 只在展开黑三角的一瞬间寻找内存中的数组。所以，任何位置展开黑三角访问同一个数组，显示的结构都是一样的！
    vs
    console.log(String(arr)), 给arr拍照。每次拍照的结果都不一样。
    总结:
        如果看数组内容，用console.log
        如果查看数组存储结构，用console.dir

    关联数组:
        索引数组的问题: 查找只能靠遍历，结果: 查找速度受存储位置和元素总数的影响极大
    关联数组解决:
        hash算法: 根据一个字符串，计算出一个尽量不重复的序号
        添加元素: 将自定义的下标名交给hash算法计算出不重复的序号，将元素保存到序号位置
        取值时: 将自定义的下标名较为hash算法，计算出和存入时相同的序号，直接去序号位置获取元素值
        优: 无需遍历, 查找速度和存储位置以及元素总数无关

    数组API
        1.转字符串：2种
            (1)var str=String(arr), 将arr中每个元素都转为字符串，用逗号分隔——给数组内容拍照
            (2)var str=arr.join("自定义连接符"), 将arr中每个元素都转为字符串，用自定义的连接符连接
        固定套路:
            (1)无缝拼接: 错误: arr.join() =>等效于String()
                     正确: arr.join("")
            (2)判断空数组: arr.join("")===""
            (3)动态生成页面元素:
                "<ANY>"+arr.join("</ANY><ANY>")+"</ANY>"
        2.拼接和选取: 都无权修改原数组，只能返回新数组，必须用变量接住新的返回值
            (1)拼接: 将其他数组或单个元素拼接到当前数组末尾
                var newArr=arr.concat(值1, 值2, arr2, ...)
                强调: concat可打散数组参数，逐个元素拼接
            (2)选取: 复制原数组中指定开始位置到结束位置之间的元素组成新数组返回。
                var subArr=arr.slice(starti,endi+1);
                复制starti位置开始到endi位置的元素，组成新数组返回
                强调: 凡是两个参数都是下标的函数，都含头不含尾
                简写:
                    (1)省略第二个参数表示从starti一直到结尾
                    (2)支持负数参数,表示倒数第n位,选择最后n个元素
                        arr.slice(-n) => 相当于 arr.slice(arr.length-n)
                    (3)如果省略两个参数，表示复制整个数组
        3.修改数组: splice 删除，插入，替换数组中的元素
            强调: 直接修改原数组
            (1)删除: arr.splice(starti,n) 删除starti位置开始的n个元素
                强调: 不用考虑含头不含尾，因为只有第一个参数是下标。n不用+1。
                简写:
                    (1)省略n，会一直删到结尾
                    (2)支持负数参数, 等效于length-n
                其实: splice有返回值:
                var deletes=arr.splice(starti,n);
                deletes是被删除的元素组成的临时数组
            (2)插入: arr.splice(starti,0,值1,值2,....)
                在starti位置插入值1,值2,... 原位置的值向后挤压
                强调: splice不支持打散数组参数，如果传入子数组，会将子数组整体保存在一个下标内。
            (3)替换: arr.splice(starti,n,值1,值2,...)
                先删除starti开始的n个元素，再在starti位置插入新值1,值2,...
                强调: 删除的元素个数和插入的新元素个数不必一致
        4.翻转: arr.reverse();
            强调: 不负责排序，只是原样颠倒
        5.排序:
            如何：2种
            自定义排序算法: 冒泡，快速，插入
            (1)arr.sort() 默认将arr中每个元素转为字符串，再按升序排列
                问题: 只能对字符串类型，升序排列
                解决: 自定义一个比较器函数
        6.栈和队列
            栈
            js中没有专门的栈和队列类型，都是用数组+API模拟的栈(stack): 一端封闭，只能从另一端进出的数组
            何时: 希望始终操作最后进入数组的最新元素时
            开头封闭，从结尾出入栈:
                结尾入栈: arr.push(值) => arr[arr.length]=值
                结尾出栈: var last=arr.pop()
            结尾封闭，从开头出入栈:
                开头入栈: arr.unshift(值)
                开头出栈: var first=arr.shift()
            队列(queue)
                结尾入队列: arr.push(值)
                开头出队列: var first=arr.shift()




String
    内置对象  包装类型
    什么是: 由多个字符组成的一个只读字符数组
    vs
    数组
    相同:
        下标, 访问每个字符
        length, 记录字符的个数
        concat和slice，拼接或选取数组内容
    不同: 字符串无法使用除concat和slice之外的数组API

    (1) 包装类型
        什么是: 专门封装一个原始类型的值，并提供操作值的API的类型。
    (2) String API
        所有StringAPI都无权修改原字符串，只返回新字符串

        (1) 大小写转换: 将str中所有字母统一转为大写/小写
            str.toUpperCase(); str.toLowerCase();
        (2) 获取指定位置的字符
            str.charAt(i) => str[i]
        (3) 获取指定位置的字符的unicode号
            str.charCodeAt(i) 获得str中i位置的字符的unicode号
        (4) 将unicode号反向转为正文
            String.fromCharCode(unicode);
        (5) 获取子字符串
            str.substring(starti,endi+1) =>str.slice(starti,endi+1)
            强调: substring不支持负数参数
            解决: length-n 表示倒数第n个
            str.substr(starti,n) 获取str中starti开始的n个字符
        (6) 查找关键词: 4种
            1. 查找一个固定的关键词出现的位置:
                var i=str.indexOf("关键词",fromi);
                在str中从fromi位置开始，找下一个"关键词"出现的位置
                如果没找到，返回-1
                强调: 每次只能找下一个关键词的位置
                如果找所有，必须用循环反复调用

                查找最后一个关键词的位置:
                var i=str.lastIndexOf("关键词");
            2.使用正则判断是否包含符合规则的关键词
                var i=str.search(/正则/i)
                在str中查找符合正则要求的关键词，返回其位置
                如果找不到，返回-1
            3.查找所有关键词的内容
                var kwords=str.match(/正则/ig)
                查找str中所有符合正则要求的关键词，保存在结果数组kwords中
                如果找不到，返回null!
                强调: 只要API的返回可能是null，就必须先验证不是null，再使用！
        (7) 替换
            将字符串中找到的敏感词替换为新内容
            1.简单: 将所有敏感词替换为一个统一的新值
                str=str.replace(/正则/ig,"新值");
            2.高级: 根据不同的敏感词，动态选择要替换的新值
                str=str.replace(/正则/ig,function(kword){
                    return 根据kword动态选择不同的替换值返回
                })
                其中: replace会在每个找到的关键词上执行function
                每次执行，都会将本次找到的敏感词自动赋值给kword参数变量。
            (3) 替换: 衍生
            删除关键词: 将关键词替换为空
            格式化: 将原字符串分组后，再按新的格式拼接
                2步: 1. 用正则将原字符串分组
                    每个分组会自动获得一个分组序号
                    从1开始
                    2. 在替换值中使用$n代替每个分组的子内容
        (8)切割
        将字符串按指定的关键词分隔为多段子字符串
        简单: 分隔符是固定的
            var subStrs=str.split("分隔符");
            返回切割后的子字符串组成的数组
            强调: 切割后的数组中不包含分隔符
        高级: 分隔符不固定时
            var subStrs=str.split(/正则/);
        固定套路:
            1. 将字符串打散为字符数组: str.split("")
            2. 将页面元素的内容转为数组:
            var arr=
            str.replace(/^\s*<ANY>|<\/ANY>\s*$/)
            .split(/<\/ANY>\s*<ANY>/)




正则表达式
    什么是: 规定一个字符串中字符出现规律的表达式
    2种
        按照规则模糊匹配多种关键词
        按照规则验证字符串格式时

    字符集
        什么是: 规定一位字符可选字符列表的集合
        何时: 如果一位字符，有多种备选字时
        如何: [备选字符列表]
        强调: 一个字符集只能匹配1位
        简写: 如果备选字符列表中字符是连续的，可用-省略中间的字符
            1位数字: [0-9]
            1位小写字母: [a-z]
            1位大写字母: [A-Z]
            1位字母:[A-Za-z]
            1 位汉字: [\u4e00-\u9fa5]
        预定义字符集
            什么是: 对常用字符集的简化写法
            包括:
                一位数字: \d    [0-9]
                一位字母,数字或下划线: \w  [0-9A-Za-z_]
                一位空字符: \s  空格，制表符等空字符
                通配符:  .  任意字符
                强调: 只有在规则完全匹配时才能使用预定义字符集
        量词
            什么是: 规定一位字符集出现次数的规则
            何时: 只要规定一位字符集出现的次数
            如何:
                强调: 总是跟在字符集之后
                1.有明确范围的:
                    6~8位    {6,8}
                    6位以上   {6,}
                    必须6位   {6}
                2.没有明确范围
                    ?    可有可无，最多一个
                    *    可有可无，多了不限
                    +    最少一个，多了不限
        选择和分组
            1.选择: 在多个条件中选其一匹配
                规则1|规则2    其中|读作或
            2.分组: 将多个规则编为一组
                为什么: 默认一个量词只能修饰一个字符集
                何时: 只要希望一个量词可修饰多个字符集时
        指定匹配位置
            ^ 匹配字符串开头   [^] 这里的尖号代表是除了的意思
            $ 匹配字符串结尾
            \b 匹配单词边界: 开头 结尾 标点 空字符

    什么是: 专门封装一条正则表达式，并提供使用正则表达式执行验证和查询的API
    何时: 2种:
      1. 验证字符串格式
      2. 即查找关键词内容，又找位置时
    创建: 2种:
        如果正则表达式是固定的: 用正则直接量
        var reg=/正则/ig;
        强调: 如果正则中包含/，要转为\/
        如果正则表达式需要动态生成: 用new
        var reg=new RegExp("正则","ig");
    API:
        (1)验证: var bool=reg.test(str)
            验证str是否符合reg的规则要求
            问题: 正则表达式默认只要部分匹配就验证通过
            解决: 今后凡是验证必须前加^后加$
        (2)查找关键词: 即找关键词内容，又找位置:
            var arr=reg.exec(str)
            在str中查找下一个符合reg要求的关键词的位置
            返回值: arr: [
                0: 本次找到的关键词
                index: 关键词的位置
            ]
            如果找不到，返回null
            强调: 1. 每次只能找一个
            反复调用,可自动找下一个
            reg.lastIndex属性记录下次开始的位置
            默认从0开始
            每找到一个关键词,就将lastIndex修改为:
            arr["index"]+arr[0].length




Math
    什么是: 专门封装数学计算所用的常量和函数的对象
    如何: Math不用创建(不能new)，就可直接使用
    API:
        1.取整
            上取整: 只要小数部分超过，就取下一个整数
            Math.ceil(num)
            下取整: 舍弃小数部分
            Math.floor(num)
                vs parseInt 相同: 都是舍弃小数部分
                不同: parseInt可去掉数字后非数字字符
                Math.floor只能转换纯数字
            四舍五入取整: Math.round(num)
                vs n.toFixed(d)
                Math.round()只能取整，不能指定小数位数
                n.toFixed(d) 可按任意小数位数四舍五入
                返回值: Math.round()返回number，可直接计算
                n.toFixed(d)返回字符串
        2.乘方和开平方
            乘方: Math.pow(底数,幂)
            比如: 10的2次方: Math.pow(10,2) =>100
            开平方: Math.sqrt(num)
        3.最大值和最小值
            Math.max(值1, 值2, ...)
            Math.min(值1, 值2, ...)
            问题: 不支持获得数组中的最大/小值
            解决: Math.max.apply(null,arr)
        4.随机数
            Math.random()  0<=r<1
            min~max之间取随机
                Math.floor(Math.random() * (max - min + 1) + min);
            0~max
                Math.floor(Math.random()*(max +1))




Date
    什么是: 专门封装一个时间，并提供操作事件的API
    何时: 今后只要保存和操作时间
    如何:
        创建: 4种:
        1. 创建日期对象，同时获得当前系统时间:
            var now=new Date();
            强调: 获取的是客户端本地时间
        2. 创建日期对象，封装自定义时间
            var date=new Date("yyyy/MM/dd hh:mm:ss")
            new Date(yyyy,MM-1,dd,hh,mm,ss)
        3. 使用毫秒数创建:
            var date=new Date(ms); //ms转换当地时区时间
            何时: 今后服务器上存储时间都是用毫秒数
            因为不用考虑时区问题
            客户端就需要用new Date将毫秒数转为当地时区对应的时间显示
        4. 复制一个日期:
            var date1=new Date(xxx);
            var date2=new Date(date1);
            何时: 因为日期的计算都是直接修改原日期对象
            所以旧时间无法保留
            如果希望同时保留计算前后的两个时间时
            就必须先将原日期复制一个副本，再用副本计算
    API:
        单位: FullYear  Month  Date  Day Hours   Minutes  Seconds  Milliseconds
        1. 每个单位都有一对儿getXXX/setXXX方法
            其中: getXXX() 负责获取指定单位的值
            setXXX(n) 负责设置指定单位的新值
            setXXX(n)可自动根据n调整进制
            特例: Day没有setDay()方法，星期不允许修改
        2. 取值范围: 月中的日(date) 从1~31结束
            其余都是从0开始到进制-1结束：
            Month: 0~11 比现实少1
            Date: 1~31
            Day: 0~6
            hours: 0~23
            minutes/seconds: 0~59
        3.计算: 2种:
            1. 两日期对象可直接相减，结果是毫秒差
                何时: 计算倒计时
            2. 对一个日期的任意单位做加减:
                3步: 1.取值, 2.计算, 3.放回去
                其实可简化为: date.setXXX(date.getXXX()+n)
        4.日期的格式化:
            date.toString() 将日期转为当地时间的完整格式
            date.toLocaleString() 将日期转为当地时间的简化格式
            date.toLocaleDateString() 仅保留日期部分
            date.toLocaleTimeString() 仅保留时间部分
            date.toGMTString(); 将当地时间转为0时区标准时间

    在ECS5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数
    如果浏览器不支持可用+操作符把Date对象转换成字符串，也能达到同样的目的
        var start = +new Date();


Error
    什么是错误(bug): 程序执行过程中导致程序无法继续执行的情况
    一旦出现错误，程序都会强行退出。
    什么是错误处理: 即使程序出错也保证不会强行退出的机制
    如何:
         try{
          可能出错的代码
         }catch(err){//只在发生错误时才执行
          错误处理代码: 1. 提示用户, 2. 记录日志
         }
     其中: err 错误对象: 在发生错误时自动创建的保存错误信息的对象。

     错误的类型: 6种
     SyntaxError : 语法错误
     ReferenceError: 引用错误, 找不到要使用的变量
     RangeError: 范围错误, 参数超范围
     TypeError: 类型错误, 错误的调用了类型的函数

     EvalError, URIError

     效率: 频繁使用try catch可能降低程序的效率
     解决: 如果可提前预知错误原因，可用if else代替try catch

     主动抛出错误:
        throw new Error("自定义错误提示")





Function
    如何:
        创建: 3种:
        1. 声明: function 函数名(参数列表){
            函数体;
            return 返回值;
          }
            参数: 只要函数必须某些数据才能正常执行时
            返回值: 如果调用者需要获得函数的执行结果时
            强调: 声明提前hoist
            什么是: 在程序开始执行前，都会先将var声明的变量和function声明的函数提前到当前作用域的顶部集中创建。但是, 赋值留在原地！
        2. 直接量: var 函数名=function(参数列表){...}
            揭示了函数的本质:
            函数名其实就是一个普通的变量
            函数是封装代码段的引用类型的对象
            函数名通过地址引用函数
            强调: 直接量方式不会被声明提前
            何时: 只要不希望函数的定义被声明提前时
        3. 用new:
        var 函数名=
    		new Function("参数1","参数2",...,"函数体");
            强调: 所有参数都必须写在""中

    函数内部属性
        在函数内部，有两个特殊的对象：arguments和this。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个
        指针，指向拥有这个arguments对象的函数。
        非常经典的阶乘函数
            function factorial(num){
                if (num <= 1) {
                    return 1;
                }esle{
                    return num * arguments.callee(num-1);
                }
            }
        ECS5也规范了另一个函数对象的属性：caller，这个属性中保存着调用当前函数的函数引用，如果是在全局作用域中调用调用当前函数，它的值为null
        为了实现更松散的耦合，也可以通过arguments.callee,caller来访问相同的信息
        当函数在严格模式下运行时，访问arguments.callee会导致错误。
        在严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。



重载: overload
    什么是: 相同函数名，不同参数列表的多个函数，在调用时可根据传入参数的不同，自动选择对应的函数执行
    为什么: 减少API的个数
    何时: 只要同一件事, 根据不同的参数，执行不同的逻辑
    如何:
        问题: js语法默认不支持重载
        解决: arguments
        什么是: 函数内自动接收传入函数的所有参数值的类数组对象。
        何时: 不确定参数个数时,就可用arguments接收所有参数值
        如何:
            1. 每个函数内都自动创建了arguments对象
            2. 类数组对象: 长的像数组的对象:
                相同:
                    1. 下标，访问每个元素
                    2. length属性，记录元素个数
                不同: 类型不同:
                    数组: Array  可使用Array中的所有API
                    类数组对象: Object 无法使用Array API
        arguments vs 参数
            参数的作用:
                1. 提示调用者如何正确使用函数
                2. 在函数内用最简单的方式表示一个有意义的值
                总结: 绝大多数函数，必须使用参数接收数据
                只有参数个数不确定时，才被迫使用arguments





匿名函数
    什么是: 定义函数时不指定函数名的函数
    为什么: 只用一次，节约内存
    何时: 只要一个函数，只调用一次，就立刻释放时
    如何:
        1. 回调: 将一个函数传入另一个函数，被另一个函数执行
            比如: arr.sort(function(a,b){return a-b})
        2. 自调: 定义函数后，立刻调用自己，调用后立刻释放
            为什么: 划分临时函数作用域，避免产生全局变量
            何时: 只要不希望产生全局变量时
            如何:
                +function(){...}()
                (function(){...})()
                (function(){...}())
    总结: 只要能在匿名函数中指定的代码，都首选匿名函数
    除非一个函数确实要被反复调用，采用有名函数





作用域和作用域链
    什么是作用域(scope): 变量的可用范围
    包括: 2种:
    1. 全局作用域: window
        全局变量:
            优: 随处可用，可反复使用
            缺: 极容易被全局污染——尽量不要使用全局变量
    2. 函数作用域: 活动对象AO
        局部变量:
            优: 仅函数内可用,不会被污染
            缺: 无法反复使用
    函数生命周期:
        0. 程序开始执行时:
            创建执行环境栈: 执行过程中，保存正在调用的函数的执行环境
            首先压入全局执行环境元素
            其次创建全局作用域window对象
            ECS中的全局执行环境元素引用window对象
        1. 函数定义:
            创建函数对象，保存函数的代码段
            函数名其实是一个引用函数对象的变量
        2.函数调用开始时:
            在执行环境栈中压入当前函数的执行环境元素
            为本次函数调用创建活动对象AO
            什么是AO: 专门保存本次函数调用时使用的局部变量的对象.
            执行环境元素引用着活动对象
        3. 函数调用过程中:
             所有变量的使用顺序: 先局部，再全局
        4. 函数调用后:
            本次函数调用的执行环境元素出栈
            导致函数作用域对象一同释放
            导致其中的局部变量也释放

        什么是作用域链: 由多级作用域对象组成的链式结构
        保存着所有变量, 控制着变量的使用顺序





闭包
    什么是：既重用变量，又保护变量不被污染的一种机制
    为什么：全局变量：优：可反复使用
                   缺：易被污染
           局部变量：缺：无法反复使用
                    优：仅函数内可用，不被污染
    何时：只希望重用一个变量，又不希望变量被污染时
    如何：三大特点
        用外层函数包裹受保护的变量和操作变量的内层函数
        外层函数返回内层函数的对象
        调用外层函数，获得内层函数的对象
    闭包如何形成：外层函数的作用域对象(AO)，无法释放
    鄙视：2步判断闭包输出
        1.找受保护的变量，判断在外层函数调用后，受保护的变量值
        2.找到所有操作受保护变量的内层函数
    特殊：如果闭包只希望创建一次，反复使用，外层函数就要使用匿名函数
        var fun = (function(){
                var 变量;
                return function(){}
                })
    闭包的缺点：比普通函数占用更多内存
            容易内存泄漏(外层函数的AO始终不释放)
    如何释放闭包：设置引用内层函数的变量为null
            导致内层函数对象释放
            导致外层函数的AO释放
            闭包就释放了




面向对象
    什么是面向对象：程序中都是先用对象来描述现实中一个事物再根据需要调用对象的方法执行操作
    如何创建对象
        第一种：var obj = {
                    属性名:属性值,
                    ...
                    方法名:function(){}
                };
        第二种：
            var obj = new Object(); new可省,()可省，不能同时省略
            obj.属性名=属性值;
            obj.方法名=function(){ this.属性名};

    构造函数constructor:
        什么是: 描述一类对象相同结构的函数
        为什么: 用直接量反复创建对象，会产生大量重复代码，不便于维护
        何时: 只要反复创建多个相同结构的对象时
        作用: 1. 描述结构, 2. 创建对象，并存储属性值
        如何: 2步:
            1. 定义构造函数
            function 类型名(属性参数列表){
                       this.属性名=属性参数;
                             ... = ... ;
                       this.方法名=function(){
                         ... this. 属性名 ...
                       }
                     }
             2. 调用构造函数:
             var obj=new 类型名(属性值列表);
             new: 4件事:
               1. 创建一个新的空对象
               2. 让新对象继承构造函数的原型对象
               3. 用空对象调用构造函数: 调用构造函数，并将this自动指向新对象
               4. 返回新对象的地址

               访问对象的成员:
                对象.属性名  -> 用法和普通的变量完全一样
                对象.功能名() -> 用法和普通的函数完全一样
                问题: 对象的方法中不能写死属性值
                解决: 对象的方法如何访问自己的属性
                自己的 => this.

                this: 函数作用域中自动定义的
                引用调用函数时.前的对象
                总结: 今后，对象自己的方法，要使用自己的属性，必须加this.
                *** this 在方法调用时，自动获得调用方法的 .前的对象
                原理：this在函数调用时，自动存储在函数作用域对象(AO)中被自动设置为引用当前函数 .前的对象

    封装
    继承
        封装的问题: 将方法定义在构造函数中，会为每个对象都创建相同方法的副本。浪费内存
        解决: 继承
        什么是：父对象中的成员，子对象不必反复创建，可直接使用
        为什么：既代码重用，又解决内存
        js中的继承都是通过原型对象实现的
        何时: 只要同一类型的多个子对象，有相同的成员时，都要将相同的成员集中保存在原型对象中一份即可。所有子对象自动共享
        如何：
            原型对象(prototype):集中存储一类子对象共有成员的父对象
            访问原型对象：
                定义构造函数时，都会自动定义一个该构造函数的原型对象
                构造函数中有一个prototype属性指向当前类型的原型对象
                向原型对象中添加共有成员
                    类型名.prototype=成员
        原型链: 由多级父元素连续继承形成的链式结构
        保存着所有的属性和方法
        控制着成员的使用顺序: 延原型链自底向上依次查找使用
        vs
        作用域链: 保存着所有的变量，控制着变量的使用顺序

    面向对象三大特点：封装 继承 多态
        封装：将一个事物的属性和功能集中定义在一个对象中
        继承：父对象中的成员，子对象可以直接访问
        多态：同一个事物，在不同情况下表现出不同的状态

        继承
        js中的继承都是通过原型对象实现的
        原型对象：集中存储一类对象的共有成员的父对象
            访问：构造函数prototype
            向原型对象中添加成员：构造函数.prototype.成员 = function(){}
            构造函数创建出的子对象，都有__proto__属性继承构造函数的原型对象prototype

            自有属性和共有属性：
                自有属性：直接保存在子对象本地的属性都是自有属性
                共有属性：保存在父级原型对象中，被所有子对象共有的属性为对象扩展属性
                为对象扩展属性
                    为单个对象扩展自有属性:对象.属性名 = 值
                    为一类对象扩展共有属性:构造函数.prototype.属性名 = 值
                修改属性
                    修改自有属性:对象.属性名 = 值
                    修改共有属性:必须用 构造函数.prototype.属性名 = 值
                删除属性
                    删除自有属性：delete 对象.属性名
                    删除共有属性：必须用 delete 构造函数.prototype.属性名
            判断自有还是共有：
                判断自有属性：var bool = Object.hasOwnProperty("属性名")
                    判断Object的本地是否包含自有属性"属性名"
                判断共有属性：!Object.hasOwnProperty("属性名") && Object.属性名
        内置对象的原型对象：
            new Array() String() RexExp() Date() Error() Function() Object()
            一切都是构造函数
            每个类型都对应自己的prototype对象
            prototype对象中集中存储着该类型可用的所有API

        原型链(prototype chain):由各级父元素连续继承，形成的链式结构
        控制着：对象.属性的使用顺序
            先用自有的，如果没有，才沿原型链向上找
            vs
            作用域链：控制值不带.的不同变量的使用范围
                先局部，再用全局
        鄙视题 判断一个对象是不是数组类型  有几种办法
            错误方法:tyoeof()--只能区分原始类型和function,无法区分内置对象类型
            解决
                1.判断原型对象：
                    var bool = father.isPrototypeOf(child);
                        判断father是不是child的父对象 不是太准确只要通过修改过prototype  就判断不准确
                2.判断构造函数
                    var bool = child instanceof 构造函数
                    判断child 是不是用指定构造函数创建出来的  不是太准确只要通过修改过prototype  就判断不准确
                    instanceof:实例：用构造函数创建出一个子对象
                    实例化：用new调用构造函数创建一个对象
                问题：前两个检查不仅检查直接父对象，而且还检查整个原型链
                3.检查对象的class属性： 检查与原形链无关
                    每个对象中都有一个内部属性class:记录了对象创建时的类型，一旦创建，不会更改
                    问题：class不允许.直接访问
                    解决:obj.toString() -> '[object Object]'
                    问题2:多少内置对象重写了toString方法
                        重写的toString方法已经无法返回class
                    解决：临时借用函数
                        函数.call(对象) -> 对象.函数()
                        Object.prototype.toString.call(obj1)
                4.Array.isArray();

        多态：同一个方法在不同情况下表现出不同状态
            重写：子对象觉得父对象的成员不好用
                可在本地定义同名自由属性，覆盖父对象成员
                使用时，优先使用子对象成员
            为什么：体现子对象和父对象之间的差异

        自定义继承：
            1.修改子对象__proto__指向指定的父对象
                child.__proto__ = fathar;
                问题：__proto__时内部属性，可能禁用：
                解决：获得父对象:Object.getPrototypeOf(child)
                        获得child的原型父对象
                    设置父对象:Object.setPrototypeOf(child,father)
                        设置child继承father
            何时：如果只修改两个对象之间的继承
            2.通过修改构造函数的prototype属性，同时修改所有子对象的父对象
                构造函数.prototype = father;
                强调：时机 一定在开始创建对象前就换
            3.两种类型间的继承
                何时：只要发现两个类型间拥有相同的属性结构和方法
                如何：
                    1.定义抽象父类型，保存子类型共有的属性结构和方法定义
                        父类型的构造函数中保存：共有的属性结构
                        父类型的原型对象中保存：共有的方法定义
                    2.在子类型构造函数中调用父类型构造函数
                        问题：不能直接调用
                            如果直接调用父类型构造函数中的this->window
                        解决用:call
                            2功能
                                1.借用本来不能调动的函数
                                2.替换函数中this指定的对象
                    3.让子类型原型对象继承父类型原型对象





ES5
    对象的属性
        命名属性：可直接用.访问的属性
            数据属性：直接存储一个属性值的属性
                四大特性:{
                    value:实际存储属性值,
                    writable:true, //控制属性是否可修改 false只读 true可写可读
                    enumerable:true, //控制属性是否可枚举  fasle不可枚举  true可枚举    也能用.访问到
                    configurable:true, //控制能否删除 控制能否修改以上2个特性    属性值依然可以修改
                }
                如何获取属性的四大特性
                    var attrs = Object.getOwnPropertyDescriptory(obj,'name');
                如何修改属性的特性：
                    Object.defineProperty(obj,'属性名',{
                        特性名：值,
                        ... ...
                    })
                问题：别入也可能将特性的值改回true
                解决：只要修改特性，都要加上configurable:false 来禁止修改其它特性的值 configurable:false不可逆
                如果对象的属性不存在，则自动添加
                特性的默认值：
                    直接量中的属性，特性默认值为true
                    defineProperty添加的属性，特性值都为false
                    一次定义多个特性值
                    Object.defineProperties(Obj,{
                        name:{
                            四大特性
                        }
                    })
                    问题：无法自定义保护规则
            访问器属性：不直接存储数据，专门对其它属性提供保护
                何时：要用自定义规则保护一个属性时
                如何：
                    四大特性:{
                        get:function(){ return 属性值;}, //专门负责读取受保护的属性值
                        set:function(value){
                            //专门负责修改受保护属性值
                            //判断value符合自定义规则的要求
                            //属性名=value
                            //否则
                            //报错
                        },
                        enumerable:false/true,
                        configurable:false/true,
                    }
                原理：
                    读取obj.访问器属性时，自动调用访问器属性的get方法
                    给obj.访问器属性赋值时，自动调用set方法，参数value自动获得要赋的新值
                    问题：
                        受访问器属性保护的值不能放在普通的数据属性中
                    解决：使用闭包定义访问器属性和受保护的变量

            防篡改
                阻止对已经创建好的对象的属性结构进行篡改
                保护整个对象
                    1.防扩展：禁止添加新属性
                        检查对象的extensible:Object.isExtensible(obj);判断一个对象是否可扩展
                        禁止扩展:Object.preventExtensions(Objt);
                        将对象的extensible改为false
                    2.密封：在防扩展的基础上，在禁止删除任何属性
                        检查对象是否密封:Object.isSealed(obj);
                        设置obj密封:Object.seal(obj);
                        将对象的每个属性configurable:false
                        何时：强烈建议在构造函数结尾都要密封当前对象
                    3.冻结：在密封基础上，在禁止修改任何属性的值
                        判断对象是否被冻结：Object.isFrozen(obj);
                        冻结对象：Object.freeze(obj);
                        将对象的每个属性writable:false
                        何时：如果一个对象的所有属性值都不允许修改是
        内部属性：不允许直接用.访问的属性
            .__proto__  .class
            extensible:true

    Object.create():基于一个现有父对象
                    创建一个子对象
                    在扩展子对象的自有属性
                何时：如果先有父对象，再根据父对象创建子对象时
                如何：
                    仅创建子对象：var child = Object.create(father);
                    创建子对象时，为子对象扩展自有属性：
                        var child = Object.create(father,{
                            属性名:{
                                四大特性
                                ...
                            }
                        })
    数组API
        判断：数组中的元素是否满足指定的条件
            array.every();//检查数组中每个元素是否都满足条件
            array.some();//检查数组中是否包含满足条件的元素
            如何:
                array.every(function(val,idx,arr){ return 结论})
                val:自动获得当前元素值
                inx:自动获得当前位置
                arr:指当前正在遍历的数组
        遍历：对每个元素执行相同的操作
        arr.forEach():对原数组中每个元素执行相同的操作
            arr.forEach(function(val,inx,arr){
                arr[inx] = 新值;
            })
        var newArr = arr.map():取出原数组中每个元素的值，执行相同操作后，放入一个新数组中返回
        过滤：选取出原数组中符合条件的元素，组成新数组返回
            var subArr = arr.filter(function(val,i,arr){return 判断条件})
        汇总：依次统计数组中每个元素的值，最终得出一个结果
            var result = arr.reduce(function(prev,val,i,arr){return prev和val的汇总值})

    bind()
        什么是：基于一个现有函数，创建一个新函数，并提前绑定this
        为什么：call和apply，都是临时借用，不是永久绑定
        何时：只是希望一个函数中的this，始终固定指向一个对象。
        如何：function 原函数(参数1,参数2,...){...}
            var 新函数 = 原函数.bind(替换this的对象[,提前绑定的部分参数])
            新函数(剩余参数值)//新函数不能再用call/apply绑定this
        鄙视：
            区分call apply bind
            call和apply：临时借用函数，并替换函数中的this
                调用函数
                    参数：call：所有参数单独传入
                        apply:所有参数放入数组中集中传入
            bind：创建函数，永久绑定函数中的this
                创建函数
            事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域
                window.color = 'red';
                var o = {color:'blue'};
                function sayColor(){
                    alert(this.color);
                }
                sayColor(); //red
                sayColor.call(this); //red
                sayColor.call(window); //red
                sayColor.call(o); //blue


    严格模式：比普通js运行模式更严格的运行模式
    如何：在代码段开头："use strict";
        要求:将静默失败升级为错误
        静止对未声明的变量赋值
        增加了eval()作用域
            严格模式下，在外部访问不到eval()中创建的任何变量或函数，在严格模式下，为eval赋值也会导致错误
        不建议使用arguments.callee或caller




DOM
    核心DOM：几乎所有的浏览器100%兼容
    核心DOM：操作一切结构化文档：HTML，XML
        特点：万能，但繁琐HTML
    DOM：对核心DOM部分常用功能，专门针对HTML特点进行了简化，
        特点：简洁，但不是万能的
    总结：不必区分。优先选择简洁的API，如果实现不了，再选择核心DOM API补充
    网页上一切内容都是树上的一个节点对象Node
        节点包括四大类：document，元素，属性，文本
    DOM操作：查找->修改->添加/删除
        查找
            无论任何查找都是节点对象
            Node 三大属性
                nodeType:获得节点类型--一个数字
                    包括：
                        document    9
                        element 1
                        attribute   2
                        text    3
                nodeName:获得节点名称
                    包括：
                        document    #document
                        element 元素的标签名(全大写)
                        attribute   属性名
                        text    #text
                nodeValue:获得节点的值
                    包括：
                        document    null
                        element null
                        attribute   属性值
                        text    文字内容
            1.节点间关系查找：
                何时：只要已经获得一个节点，仅周围节点时
                节点数：包括一切网页内容的树结构
                包含2大类：
                    父子：elem.parentNode
                        elem.childNode
                        拿到的是集合(类数组对象)
                        强调：仅返回直接子节点
                        第i个子元素：elem.childNode[i]
                        elem.firstChild
                        elem.lastChild
                        兄弟：elem.previousSibling 前一个兄弟
                            elem.nextSibling    后一个兄弟
                        优：完整
                    问题：节点数中，看不见得空字符，也是文本节点，可能对查找产生干扰

                    解决：元素树
                        元素树：仅包含元素节点的树结构
                        包含2大类：
                            父子：elem.parentElement   父元素
                                elem.children   直接子元素
                                elem.firstElementChild  第一个子元素
                                elem.lastElementChild   最后一个子元素
                                elem.previousElementSibling 前一个元素
                                elem.nextElementSibling 后一个元素
                        优点：仅包含元素节点，查找时不受空字符干扰
                        缺点：不包含除元素外的一切节点，不完整
                        元素树不是一颗新的树，只是节点树的子集
            总结：如果仅获得元素时，首选元素树API，如果希望获得所有节点时，就用节点树API

            2.按HTML查找4种
                按ID查找：
                    var elem = document.getElementById("id");
                        返回值：一个元素，找不到，返回null
                        强调：只能用document调用
                按标签名查找
                    var elems = parent.getElementsByTagName('标签名');
                        返回值：元素的集合--动态集合，找不到，返回空集合
                        强调：可以在任何父元素上调用
                            不但查找直接子元素，且查找所有后代元素
                按name查找
                    var elems = document.getElementsByName('name');
                        返回值：元素的集合--动态集合，找不到返回空集合
                            强调：只能在document上调用
                按class查找：
                    var elems = parent.getElementsByClassName('class');
                        返回值：元素的集合--动态集合，找不到，返回空集合
                        强调：可以在任何父元素上调用
                            不但找直接子元素，而是找所有子代元素
                            只要class中包含指定过的类名就选择，不要求安全一样

            3.用选择器查找2种
                仅找一个元素
                    var elem = parent.querySelector('select');
                找多个元素
                    var elem = parent.querySelectorAll('select');
                返回值：非动态集合，实际存储所有数据，反复访问，也不会重复查找DOM树
                强调：任意父元素都可以强调

            总结：getXXX vs querySelector
                返回值：getXXX返回动态集合
                    querySelector返回非动态集合
                效率：首次查找效率
                    getXXX不返回所有内容，所以效率高
                    querySelector 返回所有内容，所以效率低
                易用：getXXX繁琐
                    querySelector 简洁
                结论：如果只要一个条件就能查找出结果：getXXX
                    如果查找条件复杂：querySelector

    内容
        innerHTML：获取或修改元素开始标签和结束标签之间的HTML代码片段
        textContent：获取或修改元素开始标签和结束标签之间去掉HTML标记后的纯文本内容
        兼容性：IE8不兼容，innerText

    属性
        HTML标准属性：2种
            1.核心DOM 4个
                elem.getAttribute("属性名");
                elem.setAttribute("属性名","值");
                elem.hasAttribute("属性名");
                elem.removeAttribute("属性名");

            2.HTML DOM: elem.属性名
                特例：html中的class属性与js中的class关键词冲突，所以DOM中都用className代替class属性
                问题：三大状态 disabled checked selected
                    不能用核心DOM操作，应该用HTML DOM

        自定义扩展属性
            HTML：<ANY data-属性名="值"></ANY>
            查找：使用属性选择器，查找元素：.querySelectorAll("[data-属性名='值']");
            访问：2种
                1.核心DOM：
                    问题：HTML DOM中无法用.反问自定义属性
                2.H5：elem.dataset.属性名

        样式
            内联样式：
                elem.style.css属性名 获取或设置css属性名
                    其中css属性名都要去横线变驼峰
                    强调：修改时，只能修改内联样式
                            好处：修改不会影响其他元素，且优先级最高
                        获取时：只能获得内联样式
                            问题：获得的样式不完整
                            解决：获得计算后的样式：最终应用到元素上的完整样式列表，且将所有属性值计算为最终结果。
                                var style = getComputedStyle(elem);
                                style.css属性名--只读

        添加和删除
            添加：3步
            创建空元素
                var a = document.createElement("a");
            设置关键属性
                a.href = "http://ww.baidu.com";
                a.innerHTML = ""go;
                仅在内存中创建了一个单独的元素，还未添加到DOM树
            将新元素添加到DOM树
                末尾追加：parent.appendChild(a);
                中间插入：parent.insertBefore(a,child);
                替换：parent.replaceChild(a,child);
            删除:
                parent.removeChild(a);
                    节约变量:a.parentNode.removeChild(a);

        优化：尽量少的操作DOM树
            原因：页面加载过程费时
            频繁操作DOM树，会导致频繁layout

            如何：2种
                如果同时添加父元素和子元素，就要现在内存中将子元素添加到父元素，在一次性将父元素添加到DOM树
                如果同时添加多个平级子元素，就要用文档片段
                文档片段：内存中临时保存子元素的虚拟父元素
                如何：3步
                    创建文档片段
                    var frag = document.createDocumentFragment();
                    将子元素添加到文档片段
                    frag用法和普通父元素一样
                    frag.appendChild(child);
                    将子元素添加到DOM树后,frag自动释放，不会成为实际的节点对象

        HTML DOM常用对象
            Image:代表页面上一个img元素
                创建:var img = new Image();
            Select:代表页面上一个Select
                属性：.selectIndex：获得当前选中项的下标
                    .options：获得select下所有option元素
                    .options.length 获得select下的option的个数
                    .length:等效于.option.lengths
                    .length=0 可清空select下所有的option
                    .value:获得当前select选中项的值或内容
                        如果选中项有value，则返回选项中的value
                        如果选中项没有value,则返回选中项的内容
                方法：
                    .add(option);向select下追加一个option
                    .remove(i);删除select下i位置的option
                事件：
                    .onchange:当选中项发生改变时自动触发
            Option:代表一个option元素
                创建 var opt = new Option(text,value);
                简化：向select中添加一个新的option
                    select.add(new Option(text,value));
            Form:代表网页上的一个表单元素
                获取：var form = document.forms[i/id/name];
                属性：
                    .elements 获得表单中所有表单元素
                    包括：input select textarea button
                    .elements.length 所有表单元素的个数
                    获得表单元素：.elements[i/id/name]
                        简写：只要包含name属性的元素
                        form.name
                    .length等于elements.length
                方法：手动提交 .submit();
                事件：onsubmit()：最终提交表单前自动触发
            表单中元素
                方法：
                    .focus() 让当前表单元素获得焦点
                    .blur() 让当前表单元素失去焦点





BOM
    1.打开和关闭窗口
        1.1 打开窗口：window.open("url","name");
            在当前窗口打开，可后退
            html:<a href="url" target="_self">
            js:window.opent("url","_self");
        1.2 在当前窗口打开，禁止后退
            js: location.replace("新url")
            用新url替换history中当前url
        1.3 在新窗口打开，可打开多个
            html: <a href="url" target="_blank">
            js: .open("url","_ blank ")
        1.4 在新窗口打开，只能打开一个
            html: <a href="url" target="自定义name">
            js: open("url","自定义name")
            name属性: 内存中唯一标识一个窗口的名称
            浏览器规定: 相同name属性的窗口只能打开一个 后打开的同名窗口会覆盖下打开的
        1.5 关闭: window.close();
    2.窗口大小
        2.1 窗口大小
            获取: 2种:
                完整大小:window.outerWidth/outerHeight
                文档显示区大小: 浏览器中用于显示网页的部分
                    window.innerWidth/innerHeight
    3.定时器
        3.1 周期性定时器
            让程序按照指定的时间间隔, 反复执行相同任务
            何时: 只要让程序按照指定时间间隔反复执行任务
            如何: 3件事:
                任务函数: 定时器反复执行的函数
                    function task(){...}
                启动定时器: timer=setInterval(task,间隔ms);
                    强调: 参数task后不要加()，因为不是立刻执行，而是交给定时器，代为执行——回调
                停止定时器: clearInterval(timer)
                    timer: 唯一标识一个定时器的序号
                    只能在启动定时器时，迅速获得

                停止: 2种:
                    手动调用clearInterval()
                    任务函数中设定临界值，自动判断是否结束
        3.2 一次性定时器
            让程序先等待一段时间，再执行一次任务
            何时: 只要一项任务，需要等待一段时间后，才自动执行
            如何: 3步:
                任务函数: function task(){...}
                启动定时器: 开始等待
                timer=setTimeout(task,等待ms)
                停止定时器: 停止等待，不再执行
                clearTimeout(timer)
        ***定时器的原理: 定时器中的任务函数，只能在主程序中所有函数执行完，才能开始调用。
        for(var i=0;i<3;i++){
            setTimeout("console.log(i)",0)
        }
        3个3
        定时器中回调函数的this默认都指window
        问题: 动画叠加: 反复无节制的创建新定时器，作用在同一个元素上导致混乱
        解决:
            1. 判断只有在没有动画播放时，才能启动新定时器
                if(timer==null) 才启动新动画
            2. 在启动新定时器之前，停止当前动画
                clearInterval(timer), 再启动新动画
    4.BOM常用对象
        history: 保存当前窗口打开后成功访问过的url的历史记录栈
            前进: history.go(1)    history.go(n)
            后退: history.go(-1)   history.go(-n)
            刷新: history.go(0)
        location: 封装当前窗口正在打开的url的对象
            属性:
                .href: 获取或设置完整url
                    在当前窗口打开新地址: location.href="新url"
                .protocol: 协议
                .host: 主机名+端口号
                .hostname: 主机名
                .port: 端口号
                .pathname: 网页的相对路径
                .hash: 获得#锚点地址
                .search: ?查询字符串
            方法:
                在当前窗口打开，可后退：
                    location.assign("新url") => location.href="新url"
                    简化: location="新url"
                在当前窗口打开新url，禁止后退：
                    location.replace("新url")
                重新加载:
                    location.reload(false/true);
                    前提: 服务器默认会设置静态资源缓存，让浏览器在客户端本地缓存资源，避免反复下载，浪费时间。
                    参数: force: 强迫
                        默认:false: 优先使用浏览器本地缓存的资源
                        除非服务器上的资源更新了，比本地缓存新，才从服务器下载新资源
                    改为:true: 绕过浏览器本地缓存，强制从服务器下载新的资源
        navigator: 封装浏览器配置信息的对象
            cookieEnabled: 判断是否启用了cookie
            cookie: 在客户端本地持久保存用户私密数据的小文件。
            为什么: 内存中存储的数据，一旦程序结束或关机，就不复存在。无法持久保存
            何时: 只要希望在客户端持久保存数据时
            判断:
                plugins: 封装所有插件信息的集合
                plugins["插件名"]
                userAgent: 封装浏览器名称和版本号的字符串
    5.event
        事件: 浏览器自动触发的或用户手动触发的页面元素状态的改变
        事件处理函数: 当事件发生时，自动调用的函数
        如何绑定: 3种:
            1. HTML元素的开始标签中:
                <ANY on事件名="js语句"
                问题: 不符合内容与行为分离的元素，不便于维护
                解决: 事件处理函数都是在js中集中绑定
            2. js中: elem.on事件名=function(){
                   ...this->elem...
                 }
                 问题: 一个事件只能绑定一个处理函数
                解决: addEventListener
            3. js中,添加事件监听:
                elem.addEventListener("事件名",fn)
                优: 一个事件可同时绑定多个处理函数
                elem.removeEventListener("事件名",fn)
        事件周期/模型:
            DOM: 3个阶段:
                1. 捕获: 由外向内，依次记录各级父元素上绑定的事件处理函数。到目标元素结束。
                    目标元素: 最初实际触发事件的元素
                    强调: 捕获阶段只记录函数，不调用！
                2. 目标触发: 首先触发目标元素上绑定的事件处理函数
                3. 冒泡: 按捕获顺序的反向，由内向外，依次执行捕获的处理函数
        事件对象: 事件发生时，自动创建的封装事件信息的对象
            何时: 只要希望获取事件的信息或操作事件
            如何: 事件对象默认作为处理函数的第一个参数传入
            function handler(e){ ...e->事件对象...}
        取消冒泡: e.stopPropagation();
        利用冒泡:
            问题: 浏览器在触发事件时，是遍历所有事件监听
                事件监听创建的越多，响应速度就越慢
            解决: 尽量少的添加事件监听——优化
            如何: 如果多个平级子元素，绑定相同的事件处理函数，则只需要在父元素绑定一份，所有子元素共用即可
            难题1: 如何获得目标元素:
                错误: this->父元素
                正确: e.target
            难题2: 如何判断目标元素是否想要的:
                target.nodeName
            取消事件/阻止默认行为:
                e.preventDefault();
                 2大用途:
                  1. 当用a作为按钮时，阻止在地址栏添加#
                  2. 表单提交之前，如果验证没通过，可取消提交
                    form.onsubmit: 正式提交表单之前触发
                       无论以何种方式提交表单，都会触发onsubmit
                       通常: 对表单中所有元素执行验证
                            只要一项没有验证通过，就取消提交
                  3. H5做拖拽时，都要取消浏览器默认的拖拽行为
          事件坐标:
            相对屏幕左上角: e.screenX|screenY
            相对于文档显示区左上角: e.clientX|x
                                 e.clientY|y
            相对于事件发生的元素左上角: e.offsetX|offsetY




jQuery
    1.jQuery对象:
        什么是: 用jQuery工厂函数包装DOM对象后形成的新对象
        为什么: 普通的DOM对象不包含jQuery简化版API
        何时: 只要希望使用jQuery简化版API之前，都要将DOM对象包装为jQuery对象
            如何:
            1. 将现有DOM对象包装为jQuery对象
                var $xxx=jQuery(DOM对象)
                何时: 如果已经获得了一个DOM对象，想用简化版API。 比如: this, e.target,转为jQuery对象
                var $this=jQuery(this);
                var $target=jQuery(e.target);
            2. 直接用jQuery工厂函数查找:
                var $xxx=jQuery("选择器")
                何时: 绝大多数情况，在未获得任何元素时，首选用jQuery工厂函数直接查找元素
                简写:
            引入jQuery.js文件时: 3件事:
                1. 向window中添加了一个jQuery工厂函数，用于创建jQuery类型的对象
                2. 为jQuery工厂函数添加了一个原型对象
                在jQuery工厂函数的原型对象中封装了所有简化版API。
                每次使用jQuery工厂函数获得的jQuery结果对象多继承自jQuery原型对象，可直接使用原型对象中保存的简化版API
                3. 向window中添加全局变量$，引用jQuery工厂函数。——所有jQuery都可用$代替。
            问题: 如果选择器查找到多个元素,如何保存
                其实: jQuery对象是一个类数组对象
                找到的每个DOM对象都是类数组对象中的一个元素
                且jQuery简化版API都自带forEach效果
                只需调用一次，即可自动应用到每个DOM对象上
            Chrome 控制台中也可使用$("选择器")查找元素:
                Chrome 控制台也提供了$函数，类似于jQuery的$，但无需引入jQuery也可使用。
                如何: 只找一个: $("选择器") 相当于querySelector
                找多个: $$("选择器") 相当于querySelectorAll
        2.查找
            按选择器查找: 过滤选择器
            基本过滤: 位置过滤——jQuery独有，css没有
            什么是: 根据元素在查找结果集合中的*下标*位置选择元素
                强调: 1. 将所有元素先查找到集合中，再按下标过滤
                    2. 下标从0开始
                    3. 和元素在父元素中的相对位置无关
            何时: 只要希望根据元素在结果集合中的位置查找元素
            如何: 包括:
                :first/last  获取结果集合中第一个/最后一个元素
                :even/odd  获取结果集合中偶数/奇数位置的元素
                :lt/gt/eq(i) 获取结果集合中小于/大于/等于i位置的元素
            特殊: :animated 选择正在播放动画的元素
            :not(selector) 否定伪类,同CSS
            问题: 一个.css只能设置一个css属性
                解决: $(...).css({
                css属性:值,
                ... : ... ,
                })
                强调: 1. css属性必须去横线变驼峰
                强烈建议，只要在js中使用css属性，都去横线变驼峰
                2. 如果属性值为数字, 可不加引号，且可省略单位
            子元素过滤: 同css
             什么是: 根据元素在其*父元素中*的*相对*位置选择
            			强调: 1. 序号从1开始
                      2. 序号相对于父元素内部编号
               何时: 只要根据元素在其父元素中的位置选择
               如何: 包括:
                :first/last-child 获取作为其父元素下第一个子元素的所有元素
                :nth-child(n|2n|2n+1|even|odd)
                :only-child  获取作为独生子女的子元素
        3.内容过滤: 根据元素的内容查找
            :contains(text)  查找内容中包含text的元素
                比如: span:contains("购物车")
                强调: 只能是文字中包含text的，如果是标签名中包含，则不选择。
            :empty 查找内容为空的元素
            :parent 查找内容不为空的元素  :not(:empty)
                强调: 只要包含内容(子元素或文本都行)就选择
            :has(selector) 选择包含符合selector要求的子元素的父元素
                比如: li:has(.active) 选择包含class为active的子元素的父元素li
        4.可见性过滤:
            :hidden : 选择所有不可见的元素
              让网页元素不可见: 4种:
                  display:none, visibility:hidden, opacity:0
                  type="hidden"
              但是:
            :hidden只能选择display:none的和type="hidden"的
            :visible : 选择所有可见的元素
        5.属性过滤: 同CSS的属性选择器
          什么是: 按照任意属性的任意值选择元素
            何时: 只要按除id,元素,class之外的其他属性作为条件查找时，甚至模糊查找时
            如何:
              [属性名]  选择包含指定属性的元素
              [属性名=值]  选择属性的值等于指定值的元素
              [属性名^=值] 选择属性值以指定值开头的元素
              [属性名$=值] 选择属性值以指定值结尾的元素
              [属性名*=值] 选择属性值包含指定值的元素
              [属性名!=值] 选择属性值不等于指定值的元素
                其实: :not([属性名!=值])
                强调: 即选择包含title属性，但值不符合
                     也选择不包含title属性的
            特殊: 且
             [属性选择器1][属性选择器2]...
        6.表单元素过滤:
            什么是: 利用表单元素的标签名和type属性值选择表单中的元素
            何时: 只要查找表单中的表单元素时
            如何: 包括:
            :input选择所有表单元素:input select textarea button
            每种type都对应一个选择器:
            :text :password :radio :checkbox :submit :reset
            :file :button :hidden :image
        7.状态过滤:
            什么是: 选择处于三大状态之一的元素
            何时: 只要根据元素的状态选择元素
            如何: 包括: :disabled  :checked  :selected
            练习: 问题1: .css只能修改css属性
            解决: .attr("属性名",新值) 可修改标准属性
            .attr("属性名") 获取属性值
            总结: jQuery API第二大特定:
            一个函数两用: 没提供新值，就读取属性现有值
                         提供了新值，就修改属性为新值
            问题2: .attr无法访问三大状态属性
            解决: .prop() 专门操作三大状态属性
        8.查找:
            父子:
                $(...).parent() -> elem.parentNode
                $(...).children([selector]) -> elem.children
                强调: 1. 仅查找直接子节点
                    2. 可用选择器仅选择感兴趣的子节点
                    但选择器可写可不写
                $(...).find(selector)
                查找所有后代元素中满足selector条件的子元素
                强调: 1. 不但查找直接子元素，且查找所有后代
                2. 选择器必须写
            兄弟:
                $(...).prev() 选择和当前元素紧邻的前一个兄弟
                强调: 必须紧邻的前一个
                $(...).prev([selector])
                要求: 必须紧邻的前一个且满足selector
                $(...).prevAll([selector]) 选择当前元素之前的所有兄弟
                $(...).next(...)/.nextAll(...) 同prev/prevAll
                $(...).siblings([selector]) 除自己之外的所有前后的平级兄弟
            总结: jQuery所有API通用特点: 3个
             1. 子代forEach
             2. 一个函数两用
             3. 每个API都返回正在使用的jQuery对象，为了后续链式操作
         9.修改
            内容:
                $(...).html([html代码片段]) -> elem.innerHTML
                $(...).text([文本]) -> elem.textContent
                $(...).val([值]) -> elem.value
            属性:
                $(...).attr("属性名"[,"值"]) -> elem.属性
            移除属性:
                $(...).removeAttr("属性名")
            问题: 不能访问三大状态: disabled checked selected
            解决: $(...).prop(...)
            问题: 一句attr只能修改一个属性
            解决: $(...).attr({
                属性名: 值,
                ... : ... ,
            })
            样式: $(...).css("属性名"[,"值"])
            获取: 自动获取计算后的完整样式
            修改: 自动仅修改内联样式
            强调: 凡是从页面上获得的属性/样式的值都是字符串
            如要计算，必须先转为浮点数，去单位。
            问题: 要修改的css属性很多，则代码繁琐
            解决: 今后批量修改css，都要将css集中定义在class中，通过应用class来批量修改css样式
            如何:
            1. 为元素添加class : $(...).addClass("类名",...)
            2. 从元素上移除类名 : $(...).removeClass("类名")
            3. 判断元素是否包含指定class  :
                $(...).hasClass("类名")
            4. 切换class: $(...).toggleClass("类名")
                相当于: if($(...).hasClass(...))
                $(...). removeClass("in");
                    else
                $(...).addClass("in");
        10.添加/删除/复制/替换
            添加: 2步:
                1. 用html代码片段创建新元素
                    var $elem=$("html代码片段")
                    强调: html代码片段中如果同时包含父元素和子元素，则一并创建。
                2. 将新元素添加到页面
                    $(parent).append($elem) -> appendChild
                        .prepend($elem) 在开头插入
                    $(child).before($elem) -> insertBefore
                        .after($elem) 插入到child之后
            删除: $(...).remove();
            替换:
                $(现有元素的选择器).replaceWith(新元素代码片段)
                用右边的新元素，代替左边的现有元素
                $(代码片段).replaceAll(现有元素的选择器)
                用左边创建的新元素，代替右边的现有元素
            复制:
                var $elem_clone=$(elem).clone()
                问题: 不带参数的clone仅复制属性，不复制行为
                解决: $(elem).clone(true) 即复制属性，又复制行为
                练习: $(elem).is(selector)
                判断elem是否符合selector的条件
        11.事件
            鄙视: jquery有几种事件绑定方式:
            DOM: addEventListener("事件名",fn)
               removeEventListener("事件名",函数名)
            强调: 要想移除事件监听, 必须使用有名的函数绑定事件监听
               如果添加事件监听时使用的是匿名函数,则不可能移除
               1. $("...").bind("事件名",fn)
                            .unbind("事件名",函数名)
                            两个简化:
                            .unbind("事件名") 移除该事件上绑定的所有监听函数
                            .unbind() 移除该元素上所有事件绑定
               2. $("...").one("事件名",fn)  终极版 事件委托
                       绑定事件，仅触发一次后，自动解绑
               3. 常用的事件: 23个, 更简化:  $("...").事件名(fn)
                      只对部分常用事件提供了简化
               bind函数的问题: 只能对当前页面上已有的元素添加事件绑定
               解决: 将事件bind到父元素上——利用冒泡！

               模拟操作: 用代码模拟触发另一个元素的事件
                  何时: 如果少量/个别平级元素拥有相同的事件处理函数
                           不必利用冒泡！就用模拟触发
                  如何: $("...").trigger("事件名")
                       触发所有选中元素上的指定事件处理函数
           12.页面加载后执行:
               只要将script放在body的结尾，默认就是页面加载后执行
               2种:
               1. window.onload=function(){...}
                     在页面加载后自动触发
               问题: onload: 整个加载完成: html , css , js , 图片...
                        onload中通常执行DOM操作，和css和图片无关
               解决: ondomcontentLoaded: 仅DOM树和js加载完成
                        其实domcontentLoaded时就已经可以执行DOM操作
               如何: $(document).ready(function(){...})
                                           ondomcontentLoaded:
                        简化: $().ready(function(){...})
                        更简化: $(function(){...})
               其实: 将script放在body结尾，就已经是domcontentLoaded
            13.补: hover:
                hover=mouseover+mouseout
                何时: 今后只要进入元素和移出元素时，都要执行事件操作
                如何: $("...").hover(fn1, fn2): over时执行fn1,out时执行fn2
                $("...").hover(fn) 无论over还是out都执行fn
            14.动画效果
                jquery中通过动画函数实现的动画效果——高级函数
                问题: 1. 高级函数，是用底层函数，再次进行的封装，可能发生变化
                         2. 可能有兼容性问题
                解决: 简单动画: fade+in+transition

                简单动画函数:
                   显示隐藏: $("...").show();   $("...").hide();  $("...").toggle();
                                   ->display:none 默认无动画效果:
                         添加参数: 速度: 默认三挡: slow    normal     fast
                                                  自定义毫秒数:
                         问题: 直接修改大量内联css属性实现的动画, 不可维护
                   上下滑动: $("...").slideUp();   $("...").slideDown();
                                   $("...").slideToggle();
                   淡入淡出: $("...").fadeIn();     $("...").fadeOut();
                                   $("...").fadeToggle();

                $("...").动画API(速度,easing,callback)
                  callback指在动画调用结束后，才调用callback
                  万能动画函数:
                    $("...").animate(
                       {css属性: 目标值, css属性: 目标值},//仅对数值属性有效
                       speed,
                       easing,
                       callback
                    )

                并发与排队:
                  并发: 多个动画效果同时执行!
                     $("...").animate({多个属性},speed)
                            多个属性同时变化
                  排队: 多个动画先后执行:
                     $("...").animate({先变化的属性},speed)
                               .animate({后变化的属性},speed)

                练习:
                  $("...").each(function(i){$(this)...})
                    对类数组对象中每个元素执行相同的操作
                总结: 几乎所有jquery API都返回之前的jquery对象，可用链式操作减少反复调用$(),避免反复查询和反复创建jq对象。
            15.类数组对象操作:
                .size() 获得jquery对象查询结果中元素的个数
                .get(i) 获得jquery对象中i位置的DOM元素
                .index(DOM/jq) 查找元素在jquery对象中的下标位置
                                       经常用于判断是否包含在内
                .each(callback) 对查询结果中每个元素执行相同的操作
                callback(i){this->当前正在遍历的DOM元素->$(this)->jq}
            16.自定义插件:
                何时: 只要一项功能或一个函数，被反复使用。都要将反复使用的函数或功能封装为一个插件。
                优: 复用——DRY——Reflector重构

                如何: 2种:
                    1. 为jQuery添加jQuery全局函数
                     什么是: 不依赖于任何具体DOM对象，就可直接调用的jQuery函数。
                     何时: 只要一个函数不需要查找任何DOM对象，就可直接调用时。就要将该函数定义为jquery全局函数
                     如何:
                       所有jquery的全局函数都定义在jQuery全局对象中
                       jQuery全局对象充当jQuery所有API的命名空间
                       Step1: if(window.$===undefined)
                                      //先判断是否加载了jQuery库
                       Step2: 在jQuery中添加自定义命名空间对象
                                  $.XXXLib={};
                       Step3: 在自定义命名空间中添加自定义扩展方法
                                  $.XXXLib.方法名=function(){...}

                       如何调用: 3步:
                         1. 先引jquery.js
                         2. 再引自定义lib.js
                         3. 调用: $.xxxLib.方法名();

                     鄙视: jQuery全局函数 vs ES的全局函数
                          相同点: 执行，不依赖于某一类具体对象
                          ES的全局函数，存储在全局对象window中
                                 不需要任何对象可直接调用
                          jQuery全局函数, 存储在jQuery对象中
                                 必须至少使用jQuery.才能调用
                     鄙视: $.each(list,callback) vs  $("...").each(callback)
                         相同: 都是对类数组对象中每个元素执行相同操作(callback)
                         不同:
                              1. 调用方式：
                                 $.each可对任意类数组对象执行操作
                                 $("...").each只能对$查询出的结果集合执行操作
                              2. 存储位置:
                                 $.each: 直接存在jQuery对象下
                                 $("...").each: jQuery.fn中
                                    jQuery.fn是所有查询结果对象的父对象！
                              3. 称呼:
                                 $.each: jQuery全局函数
                                 $("...").each: 称为jQuery对象方法
                     2. 为jQuery对象添加插件方法:
                       何时: 只要一项完整的效果/功能需要复用，就要将效果/功能封装为jQuery插件函数
                       如何: jQuery插件函数都要添加到jQuery.fn中
                         不需要动态生成html, 但是事先规定好html的样子
                         div>a/button+ul
                         为组件定义必须的css，保存在专门的css文件中
                         开始为jQuery.fn添加对象dropdown()方法
                            先侵入class
                            再寻找触发事件的元素，绑定处理函数
            	           修改class，达到交互的目的

                         如何使用:
                            1. 引入插件的css文件
                            2. 引入jquery.js
                            3. 引入插件的js文件
                            4. 找到父元素，调用插件方法
                               $("...").dropdown();



================================================================================

变量、作用域和内存问题
    1.基本类型和引用类型的值
        基本类型
            number
            string
            boolean
            null
            undefined
        引用类型
            引用类型的值是保存在内存中的对象，与其他语言不同，JavaScript不允许直接访问内存中的位置
            也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象
            为此，引用类型的值是按引用访问的
    2.检查类型
        typeof
        instanceof
    3.执行环境及作用域
        全局执行环境是最外围的一个执行环境
        当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain).作用域的用途，是保证对执行
        环境有权访问的所有变量和函数的有序访问
    4.没有块级作用域





引用类型
    1.Object类型
        创建Object实例的方式
        new Object();
        字面量
            var person = {
                name : 'peter',
                age : 12
            }
        var person = {} //与new Object()相同
    2.Array类型
        (1)转换
            Array.toString(); //返回以逗号分隔的字符串
        (2)栈方法
            ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为
            栈数据结构的访问规则是LIFO(后进先出)
        (3)队列方法
            队列数据结构的访问规则是FIFO(先进先出)
            结合使用shift()和push()方法，可以像使用队列一样使用数组，shift是从数组前端开始删除
            ECMASript还为数组提供了一个unshift()方法。unshift与shift()的用途相反：
            它能在数组前端添加任意个项并返回新数组的长度
        (4)重排序方法
            reverse(); //反转数组
            sort();
            sort:比较器
                比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，
                如果第一个参数应该位于第二个之后则返回一个正数。
                function compare(value1,value2){
                    if(value1 < value2){
                        return -1;
                    }else if(value1 > value2){
                        return 1;
                    }else{
                       return 0;
                    }
                }

                var values = [0,1,5,10,15];
                values.sore(compare);

                对于数值类型,可以使用一个更简单的比较器
                function compare(value1,value2){
                    return value2 - value2;
                }
            (5)操作方法
                concat(); //链接数组
                slice(start,end);  //不影响原数组
                    arr.slice(); //复制原数组
                    删除:slice(0,2);
                    插入:slice(2,0,'red','green');
                    替换:slice(2,1,'red','green');
            (6)位置方法
                ECMAScript5为数组实例添加了两个位置方法:indexOf()和lastIndexOf(),这两个方法都接收两个参数：
                要查找的项和表示查找起点位置的索引
            (7)迭代方法
                ECMASript5为数组定义了5个迭代方法
                every():对数组中的每一项运行给定函数，如果该函数对每一项都返回tru，则返回true
                filter():对数组中的每一项运行给定函数，返回该函数会返回true
                forEach():对数组中的每一项运行给函数，这个方法没有返回值
                map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
                some():对数组中的每一项运行给定函数，如果该函数对任一项返回true
            (8)归并方法
                reduce();
                reduceRight();
    3.Date类型
        var now = new Date();
        ECMASript5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数
    4.RegExp类型




面向对象
    1.理解对象
        创建对象
        new Object();
        var Obj = {}; //字面量
    2.属性类型
        ECMASript中有两种属性：数据属性和访问器属性
        (1)数据属性
        数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性
        [[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把
        属性修改为访问器属性，默认为true
        [[Enumerable]:表示能否通过for-in循环返回属性，默认为true
        [[Writable]]:表示能否修改属性的值，默认为true
        [[Value]]:包含这个属性的数据值，默认为undefined
    3.修改数据属性必须使用
        Object.defineProperty();
    4.访问器属性
        [[Configurable]]
        [[Enumerable]]
        [[Get]]
        [[Set]]
    5.定义多个属性
        Object.defineProperties();
        读取属性的特性：
            Object.getOwnPropertyDescriptor(Object,Object.name);
            只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object,getOwnPropertyDescriptor();
    6.工厂模式
        工厂模式是软件工程领域一种广为人知的设计模式，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的
        function createPerson(name, age, job){
            var o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function(){
                alert(this.name);
            };
            return o;
        }
        var person1 = createPerson('peter',29,'software');

    7.构造函数模式
        与工厂函数不同之处
            没有显示地创建对象；
            直接将属性和方法赋给了this对象
            没有return语句
            构造函数名首字母大写，非构造函数则应该小写，构造函数本身也是函数，只不过可以用来创建对象而已
            通过new创建一个新对象
            funertion Person(name, age, job){
                this.name = name;
                this.age = age;
                this.job = job;
                this.sayName = function(){
                    alert(this.name);
                }
            }
            var person1 = new Person('peter',29,'software');
            var person1 = new Person('tom',30,'software');
            这两个对象都有一个constructor(构造函数)属性，该属性指向Person：
                alert(person1.constructor == Person ); //true
                alert(person2.constructor == Person ); //true
            对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些

            instanceof 操作符
            person1 instanceof Person  //判断person1是否是Person对象的实例
        缺点：使用构造函数的主要问题，就是每个方法都要在实例上重新创建一遍

    8.原型模式
        我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法

        father.isPrototypeOf(child);
        Person.prototype.isPrototypeOf(person1);

        Object.getPrototypeOf(Object); //返回对象实际的原型

        hasOwnProperty(); //检测一个实例中是否存在此属性，不会往原型对象查找
        person1.hasOwnProperty('name');
    9.原型与in操作符
        in操作符会到实例上找，会在实例和原型对象上找
    10.要取得对象上所有可枚举的实例属性
            Object.keys(Object); //返回包含所有可枚举属性的字符串数组
    11.如果想要得到所有实例的属性，无论它是否可枚举，都可以使用
        Object.getOwnPropertyNames(Object.prototype);
    12.更简单的原型语法
        function Person(){
        }
        Person.prototype = {
            constructor:Person,
            name:"peter",
            age:20,
            job:"WEB",
            sayName:function(){
                alert(this.name);
            }
        }

        var friend = new Persion();
        Persion.prototype.sayHi = function(){
            alert('Hi');
        };
        friend.sayHi(); //"hi"
        总结：实例与原型之间的松散连接关系，尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样


    13.组合使用构造函数模式和原型模式
        构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性，就是用来定义引用类型的一种默认模式
        function Person(name,age,job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.friends = ['Shelby','Court'];
        }
        Person.prototype = {
            constructor: Person,
            sayName : function(){
                sayName : function(){
                    alert(this.name);
                }
            }
        }

    14.寄生构造函数模式
        function Person(name, age, job){
            var o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function(){
                alert(this.name);
            }
            return o;
        }
        var friend = new Person('peter',20,'software');
        friend.sayName();
        //一般不使用这种模式

    15.稳妥构造函数模式
        所谓稳妥对象，指的是没有公共属性，而且其方法不引用this的对象，稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new),或则防止数据被其它
        应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数
        function Persion(name, age, job){
            var o = new Object();
            //可在这里定义私有变量和函数
            //添加方法
            o.sayName = function(){
                alert(name);
            };
            return o;
        }
        var friend = Person('peter',29,'software');
        这里除了sayName方法之外，没有其它办法访问name，适合在安全环境运行稳妥构造函数模式

继承
    借用构造函数
        在解决原型中包含引用类型值带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即
        在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象
        上执行构造函数
        function SuperType(){
            this.colors = ["red", "blue", "green"];
        }
        function SubType(){
            //继承了SuperType
            SuperType.call(this);
        }
        var instance1 = new SubType();
        instance1.color.push("black");
        alert(instance1.colors);//red,blue,green,black

        var instance2 = new SubType();
        alert(instance2.colors);//red,blue,green

    组合继承
        组合继承，有时候也叫做伪进店继承，指得失将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式
        组合继承避免了原型链和借用构造哈叔的缺陷，融合了它们的优点，成为javascript中最常用的继承模式，而且instanceof和isPropertypeOf()也能够用
        于识别基于组合继承创建的对象

        function SuperType(name){
            this.name = name;
            this.colors = ["red", "blue", "green"];
        }
        SuperType.prototype.sayName = function(){
            alert(this.name);
        };
        function SubType(name,age){
            //继承属性
            SuperType.call(this, name);
            this.age = age;
        }

        //继承方法
        SubType.prototype = new SuperType();
        SubType.prototype.constructor = SubType;
        SubType.prototype.sayAge = function(){
            alert(this.age);
        }

        var instance1 = new SubType("peter",29);
        instance1.colors.push("black");
        alert(instance1.colors); //red,blue,green,black
        instance1.sayName(); //peter
        instance1.sayAge(); //29

        var instance2 = new SubType("Greg", 27);
        alert(instance2.colors); //red,blue,green
        instance2.sayName();//Greg
        instance2.sayAge();//27

    寄生组合式继承
        这种继承方式高效
函数
    关于函数申声明，一个重要特征就是函数声明
    递归
        arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用
        在严格模式，不能使用argument.callee如何创建递归
        这种方式在严格模式和非严格模式都可以
        function factorial(num){
            if (num < 1) {
                return 1;
            }else {
                return num * arguments.callee(num-1);
            }
        }
        改
        var factorial = (function f(num){
            if (num < 1) {
                return 1;
            }else {
                return num * f(num-1);
            }
        });

    闭包
        闭包是指有权访问另一个函数作用域中的变量函数

    事件
        事件对象
            兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法，都会传入event对象
            event对象列表
            currentTarget   Element 只读  其事件处理程序当前正在处理事件的那个元素
            preventDefault() Function   只读  取消事件的默认行为，如果cancelable是true,则可以使用这个方法
            stopPropagation() Function  只读  取消事件的进一步捕获或冒泡，如果bubbles为true,则可以使用这个办法
            target  Element 只读  事件的目标
            type    String  只读  被触发的事件类型

        IE的事件对象
            window.event
